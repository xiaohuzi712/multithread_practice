## 并发编程实践笔记

### 1.基础知识
1.  synchronized关键字可以对普通同步方法、静态同步方法、同步代码块进行加锁，保证并发
的安全。其中对于普通同步方法，锁是当前实例对象;对于静态同步方法，锁是当前类的Class对象;
对于同步代码块，锁是synchonized括号里配置的对象。
2.  每个对象都会关联一个monitor对象，当monitor对象被持有时，便处于锁定状态，线程执行到
monitorenter指令时,会尝试获取monitor对象所有权(获得对象锁)。方法同步和代码块同步即便实现
细节不一样，前者通过monitorenter指令和monitorexit指令实现同步，后者通过ACC_SYNCHONIZED指令
实现同步,其本质都是通过获取对象的monitor。monirtorenter指令是插入到编译后同步代码块的开始位置,moniterexit指令是插入达到编译后同步代码块的结束位置或异常位置。
3.  处理器通过总线锁和缓存锁来实现原子操作;Java通过CAS(compare and swap)机制和锁机制实现
原子操作。
4.  守护进程的设置必须在线程启动之前设置，否则失效;当一个Java虚拟机中不存在非守护进程时
,Java虚拟机会退出;Java虚拟机退出时，守护进程中的finally代码块不一定会执行。
5.  在JavaSE5之后，并发包新增了Lock接口，用来实现锁功能。它实现了类似synchonized关键字的
同步功能，并且需要显示的获取锁和释放锁。
6.  不要将获取锁的过程写在try代码块中，因为如果获取锁出现异常，会无故释放锁。
7.  ConcurrentHashMap使用分段锁技术提升并发访问效率。
### 2.源代码阅读